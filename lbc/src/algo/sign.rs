use std::ops::Deref;

use bip32::{ChildNumber, ExtendedKey, ExtendedKeyAttrs, Prefix};
use curv::{
    arithmetic::{BasicOps, Converter, Modulo},
    cryptographic_primitives::proofs::{
        sigma_correct_homomorphic_elgamal_enc::HomoELGamalProof, sigma_dlog::DLogProof,
    },
    elliptic::curves::{secp256_k1::Secp256k1, Point, Scalar},
    BigInt,
};

use crate::{
    lbm_client::{LubanManagerClient, Signature, TerminationType},
    MpcRound,
};
use multi_party_ecdsa::{protocols::multi_party_ecdsa::gg_2018::party_i::*, utilities::mta::*};
use sha2::Sha256;
use xuanmi_base_support::*;

use super::hd;
use crate::{Batch, RuntimeKeyStore, ToVecByKeyOrder};
use lx_grpc::prelude::tokio::sync::mpsc;
use lx_grpc::{
    lbcs::{mpc_progress::Harvest, MpcProgress},
    prelude::tonic::Status,
};
type OutputStream<T> = mpsc::Sender<Result<T, Status>>;

/// Sign a hashed message.
///
/// # Arguments
/// * `server_hostport` - mpc server URL.
/// * `uuid_tr` - transaction UUID.
/// * `derivation_path` - derivation path. If empty, use the root public key.
/// * `msg_hashed` - hashed message.
///   The algorithm check whether the message is hashed by checking its length.
/// * `keystore` - a KeyStore object previously generated by `algo_keygen`.
///
/// # Returns
/// * `Outcome<Signature>` - Ok(Signature) or Err(Ex)
#[tracing::instrument(skip(ostream, keystore_dir))]
pub async fn algo_sign(
    ostream: &OutputStream<MpcProgress>,
    keystore_dir: &str,
    owner_id: &str,
    server_url: &str,
    session_id: &str,
) -> Outcome<()> {
    // Check in
    let mut messenger = LubanManagerClient::attend(server_url, session_id, owner_id)
        .await
        .catch_()?;
    let mut progress = MpcProgress {
        current: 0,
        total: 16,
        message: String::new(),
        harvest: None,
    };
    let my_id = messenger.party_id();
    let n_actual = messenger.n_actual();
    '_validate_params: {
        let n_keygen = messenger.n_keygen();
        let threshold = messenger.threshold();
        tracing::info!(
            "n_actual={}, n_keygen={}, threshold={}",
            n_actual,
            n_keygen,
            threshold
        );
        assert_throw!(n_actual > threshold && n_actual <= n_keygen);
    }
    let ex = &format!("SignException ({}-{})", messenger.session_id(), my_id);
    progress.message("S-Attend").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Attended sign session with party_id={}", my_id);

    // Load keystore
    let key_id = messenger.key_id().to_string();
    let kspath = format!("{}/{}-{}.keystore", keystore_dir, owner_id, key_id)
        .to_lexical_abspath()
        .catch_()?;
    let keystore = RuntimeKeyStore::unmarshall_proto_file(&kspath)
        .await
        .catch_()?;
    let my_keygen_id = keystore.party_id();
    progress.message("S-LoadKeystore").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Loaded keystore file: {}", kspath);

    // #region Derive
    let mut round: usize = 1;
    let (tweak_sk, pubkey) = match messenger.derv_path().is_empty() {
        true => (Scalar::<Secp256k1>::zero(), keystore.root_pubkey.clone()),
        false => hd::algo_get_hd_key(
            messenger.derv_path(),
            &keystore.root_pubkey,
            &keystore.chain_code,
        )
        .catch_()?,
    };
    progress.message("S-DerivePubkey").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    let derv_xpub = {
        let pkb_short = pubkey.to_bytes(true).deref().to_vec();
        let ex_pk = ExtendedKey {
            prefix: Prefix::XPUB,
            attrs: ExtendedKeyAttrs {
                parent_fingerprint: [0u8; 4],
                child_number: ChildNumber(0u32),
                chain_code: keystore.chain_code,
                depth: 0u8,
            },
            key_bytes: pkb_short.try_into().unwrap(),
        };
        ex_pk.to_string()
    };
    tracing::debug!("Derived pubkey: {}", derv_xpub);
    // #endregion

    // #region round 1: collect signer IDs
    messenger
        .send_broadcast(round, &my_keygen_id)
        .await
        .catch_()?;
    let mut batch_keygen_id: Batch<usize> = messenger.recv_broadcasts(round).await.catch_()?;
    let _ = batch_keygen_id.insert(my_id, my_keygen_id);
    let vec_keygen_id_minus_1: Vec<u16> = batch_keygen_id
        .values_sorted_by_key_asc()
        .iter()
        .map(|x| *x as u16 - 1)
        .collect();
    for (party_id, keygen_id) in batch_keygen_id.iter() {
        if *party_id != my_id && *keygen_id == my_keygen_id {
            throw!(
                ex,
                &format!(
                    "Duplicated keyshare (my_keygen_id={}, party_id={})",
                    my_keygen_id, party_id
                )
            );
        }
    }
    round += 1;
    progress.message("S1").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Collected signers' keygen_party_ids");
    // #endregion

    // #region round2: send commitment
    // to be practically tricky, only applicable to sign
    // (1) ignore sign_at_path
    // (2) omit updates for all ui
    // (3) only update u1 * G as (u1 + tweak_sk) * G and all xi as (xi + tweak_sk)
    let mut batch_vss_scheme = keystore.batch_vss_scheme.clone();
    let _1 = batch_vss_scheme.get(&1).unwrap().commitments[0].clone();
    let _2 = Point::generator() * &tweak_sk;
    batch_vss_scheme.get_mut(&1).unwrap().commitments[0] = _1 + _2;
    let mut private =
        PartyPrivate::set_private(keystore.party_keys.clone(), keystore.shared_keys.clone());
    private = private.update_private_key(&Scalar::<Secp256k1>::zero(), &tweak_sk);
    let sign_keys = SignKeys::create(
        &private,
        batch_vss_scheme.get(&my_keygen_id).unwrap(),
        my_keygen_id as u16 - 1,
        &vec_keygen_id_minus_1,
    );

    let (bc1, decom1) = sign_keys.phase1_broadcast();
    let (ma, _) = MessageA::a(&sign_keys.k_i, &keystore.party_keys.ek, &[]);

    messenger
        .send_broadcast(round, &(bc1.clone(), ma.clone()))
        .await
        .catch_()?;

    let batch_bc1_ma: Batch<(SignBroadcastPhase1, MessageA)> =
        messenger.recv_broadcasts(round).await.catch_()?;
    let mut batch_bc1: Batch<SignBroadcastPhase1> = batch_bc1_ma
        .iter()
        .map(|(k, v)| (*k, v.0.clone()))
        .collect();
    let _ = batch_bc1.insert(my_id, bc1.clone());
    let batch_ma: Batch<MessageA> = batch_bc1_ma
        .iter()
        .map(|(k, v)| (*k, v.1.clone()))
        .collect();
    // batch_ma.insert(my_id, ma.clone());
    round += 1;
    progress.message("S2").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Exchanged commitments");
    // #endregion

    // #region do MtA/MtAwc (c) (d)
    let mut batch_mb_gamma: Batch<MessageB> = Batch::with_capacity(n_actual);
    let mut batch_mb_w: Batch<MessageB> = Batch::with_capacity(n_actual);
    let mut batch_beta: Batch<Scalar<Secp256k1>> = Batch::with_capacity(n_actual);
    let mut batch_ni: Batch<Scalar<Secp256k1>> = Batch::with_capacity(n_actual);
    for party_id in 1..=n_actual {
        if party_id == my_id {
            continue;
        }
        let (mb_gamma, beta_gamma, _, _) = match MessageB::b(
            &sign_keys.gamma_i,
            keystore
                .batch_paillier_key
                .get(batch_keygen_id.get(&party_id).unwrap())
                .unwrap(),
            batch_ma.get(&party_id).unwrap().clone(),
            &[],
        ) {
            Ok(__) => __,
            Err(_) => throw!(
                ex,
                &format!("Invalid range proof of k_i where i={}", party_id)
            ),
        };
        let (mb_w, beta_wi, _, _) = match MessageB::b(
            &sign_keys.w_i,
            keystore
                .batch_paillier_key
                .get(batch_keygen_id.get(&party_id).unwrap())
                .unwrap(),
            batch_ma.get(&party_id).unwrap().clone(),
            &[],
        ) {
            Ok(__) => __,
            Err(_) => throw!(
                ex,
                &format!("Invalid range proof of k_i where party_id={}", party_id)
            ),
        };
        let _ = batch_mb_gamma.insert(party_id, mb_gamma);
        let _ = batch_mb_w.insert(party_id, mb_w);
        let _ = batch_beta.insert(party_id, beta_gamma);
        let _ = batch_ni.insert(party_id, beta_wi);
    }
    progress.message("S2.1").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Finished MtA/MtAwc(c)(d)");
    // #endregion

    // #region round 3: send Paillier ciphertext
    for party_id in 1..=n_actual {
        if party_id == my_id {
            continue;
        }
        let to_send = (
            batch_mb_gamma.get(&party_id).unwrap().clone(),
            batch_mb_w.get(&party_id).unwrap().clone(),
        );
        messenger
            .send_p2p(party_id, round, &to_send)
            .await
            .catch_()?;
    }
    let batch_r2_mb_mb: Batch<(MessageB, MessageB)> =
        messenger.recv_all_p2p(round).await.catch_()?;
    let batch_mb_gamma_recv: Batch<MessageB> = batch_r2_mb_mb
        .iter()
        .map(|(k, v)| (*k, v.0.clone()))
        .collect();
    let batch_mb_w_recv: Batch<MessageB> = batch_r2_mb_mb
        .iter()
        .map(|(k, v)| (*k, v.1.clone()))
        .collect();
    round += 1;
    progress.message("S3").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Finished sending Paillier ciphertext");
    // #endregion

    // #region do MtA (e) / MtAwc (e) (f)
    let batch_xi_com = Keys::get_commitments_to_xi(&batch_vss_scheme.values_sorted_by_key_asc());
    let batch_xi_com: Batch<Point<Secp256k1>> = batch_xi_com
        .iter()
        .enumerate()
        .map(|(i, v)| (i + 1, v.clone()))
        .collect();

    let mut batch_alpha: Batch<Scalar<Secp256k1>> = Batch::with_capacity(n_actual);
    let mut batch_mu: Batch<Scalar<Secp256k1>> = Batch::with_capacity(n_actual);
    for party_id in 1..=n_actual {
        if party_id == my_id {
            continue;
        }
        let m_b = batch_mb_gamma_recv.get(&party_id).unwrap().clone();
        let alpha_ij_gamma =
            match m_b.verify_proofs_get_alpha(&keystore.party_keys.dk, &sign_keys.k_i) {
                Ok(v) => v,
                Err(e) => throw!(
                    ex,
                    &format!("{:?} wrong dlog or m_b where party_id={}", e, party_id)
                ),
            };
        let m_b = batch_mb_w_recv.get(&party_id).unwrap().clone();
        let alpha_ij_wi = match m_b.verify_proofs_get_alpha(&keystore.party_keys.dk, &sign_keys.k_i)
        {
            Ok(v) => v,
            Err(e) => throw!(
                ex,
                &format!("{:?} wrong dlog or m_b where party_id={}", e, party_id)
            ),
        };
        let g_w_i = Keys::update_commitments_to_xi(
            batch_xi_com
                .get(batch_keygen_id.get(&party_id).unwrap())
                .unwrap(),
            batch_vss_scheme
                .get(batch_keygen_id.get(&party_id).unwrap())
                .unwrap(),
            *batch_keygen_id.get(&party_id).unwrap() as u16 - 1,
            &vec_keygen_id_minus_1,
        );
        assert_throw!(m_b.b_proof.pk.clone() == g_w_i, ex, "");
        let _ = batch_alpha.insert(party_id, alpha_ij_gamma.0);
        let _ = batch_mu.insert(party_id, alpha_ij_wi.0);
    }

    let _va = batch_alpha.values_sorted_by_key_asc();
    let _vb = batch_beta.values_sorted_by_key_asc();
    let _vm = batch_mu.values_sorted_by_key_asc();
    let _vn = batch_ni.values_sorted_by_key_asc();
    let delta_i = sign_keys.phase2_delta_i(&_va, &_vb);
    let sigma = sign_keys.phase2_sigma_i(&_vm, &_vn);
    progress.message("S3.2").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Finished MtA(e) / MtAwc(e)(f)");
    // #endregion

    // #region round 4: send delta_i
    messenger.send_broadcast(round, &delta_i).await.catch_()?;
    let mut batch_delta = messenger.recv_broadcasts(round).await.catch_()?;
    let _ = batch_delta.insert(my_id, delta_i);
    let vec_delta = batch_delta.values_sorted_by_key_asc();
    let delta_inv = SignKeys::phase3_reconstruct_delta(&vec_delta);
    round += 1;
    progress.message("S4").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Finished sending delta_i");
    // #endregion

    // #region round 5: send decommitment to g_gamma_i
    messenger.send_broadcast(round, &decom1).await.catch_()?;
    let batch_decom = messenger.recv_broadcasts(round).await.catch_()?;
    let vec_decom = batch_decom.values_sorted_by_key_asc();
    let vec_bc1 = {
        let mut _batch_bc1 = batch_bc1.clone();
        let _ = _batch_bc1.remove(&my_id);
        _batch_bc1.values_sorted_by_key_asc()
    };
    let vec_b_proof = {
        let mut vec_b_proof: Vec<&DLogProof<Secp256k1, Sha256>> = Vec::new();
        let keys = batch_mb_gamma_recv.keys_asc();
        for party_id in keys {
            let m_b = batch_mb_gamma_recv.get(&party_id).unwrap();
            vec_b_proof.push(&m_b.b_proof);
        }
        vec_b_proof
    };
    let R = match SignKeys::phase4(&delta_inv, &vec_b_proof, vec_decom, &vec_bc1) {
        Ok(__) => __,
        Err(_) => throw!(ex, "Bad `gamma_i` decommit."),
    };
    let R = R + decom1.g_gamma_i * &delta_inv; // add local g_gamma_i
    round += 1;
    progress.message("S5").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Finished sending decommitment to g_gamma_i");
    // #endregion

    // #region round 6: GG18 Phase(5A)
    let message_bn = BigInt::from_bytes(messenger.tx_hash());
    let two = BigInt::from(2);
    let message_bn = message_bn.modulus(&two.pow(256));
    let local_sig =
        LocalSignature::phase5_local_sig(&sign_keys.k_i, &message_bn, &R, &sigma, &pubkey);

    let (phase5_com, phase_5a_decom, helgamal_proof, dlog_proof_rho) =
        local_sig.phase5a_broadcast_5b_zkproof();
    messenger
        .send_broadcast(round, &phase5_com)
        .await
        .catch_()?;
    let mut batch_p5com1 = messenger.recv_broadcasts(round).await.catch_()?;
    let _ = batch_p5com1.insert(my_id, phase5_com.clone());
    round += 1;
    progress.message("S6").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Finished GG18 Phase(5A)");
    // #endregion

    // #region round 7: GG18 Phase(5B)
    let _to_send = (
        phase_5a_decom.clone(),
        helgamal_proof.clone(),
        dlog_proof_rho.clone(),
    );
    messenger.send_broadcast(round, &_to_send).await.catch_()?;
    let batch_p5decom1_elgamal_dlog = messenger.recv_broadcasts(round).await.catch_()?;
    let mut batch_p5decom1_elgamal_dlog_include_mine = batch_p5decom1_elgamal_dlog.clone();
    let _ = batch_p5decom1_elgamal_dlog_include_mine.insert(my_id, _to_send);
    let _keys = batch_p5decom1_elgamal_dlog.keys_asc();
    let mut vec_p5adecom1: Vec<Phase5ADecom1> = Vec::with_capacity(n_actual);
    let mut vec_elgamal: Vec<HomoELGamalProof<Secp256k1, Sha256>> = Vec::with_capacity(n_actual);
    let mut vec_dlog: Vec<DLogProof<Secp256k1, Sha256>> = Vec::with_capacity(n_actual);
    for party_id in _keys {
        let obj = batch_p5decom1_elgamal_dlog.get(&party_id).unwrap();
        vec_p5adecom1.push(obj.0.clone());
        vec_elgamal.push(obj.1.clone());
        vec_dlog.push(obj.2.clone());
    }
    let _ = batch_p5com1.remove(&my_id);
    let (phase5_com2, phase_5d_decom2) = match local_sig.phase5c(
        &vec_p5adecom1,
        &batch_p5com1.values_sorted_by_key_asc(),
        &vec_elgamal,
        &vec_dlog,
        &phase_5a_decom.V_i,
        &R.clone(),
    ) {
        Ok(__) => __,
        Err(e) => throw!(ex, &format!("`phase5c` encounters the error \"{:?}\"", e)),
    };
    round += 1;
    progress.message("S7").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Finished GG18 Phase(5B)");
    // #endregion

    // #region round 8: GG18 Phase(5C)
    messenger
        .send_broadcast(round, &phase5_com2)
        .await
        .catch_()?;
    let mut batch_p5com2 = messenger.recv_broadcasts(round).await.catch_()?;
    let _ = batch_p5com2.insert(my_id, phase5_com2.clone());
    round += 1;
    progress.message("S8").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Finished GG18 Phase(5C)");
    // #endregion

    // #region round 9: GG18 Phase(5D)
    messenger
        .send_broadcast(round, &phase_5d_decom2)
        .await
        .catch_()?;
    let mut batch_p5ddecom2 = messenger.recv_broadcasts(round).await.catch_()?;
    let _ = batch_p5ddecom2.insert(my_id, phase_5d_decom2.clone());
    let vec_p5adecom1 = {
        let mut vec_p5adecom1: Vec<Phase5ADecom1> = Vec::with_capacity(n_actual);
        let keys = batch_p5decom1_elgamal_dlog_include_mine.keys_asc();
        for party_id in keys {
            let obj = batch_p5decom1_elgamal_dlog_include_mine
                .get(&party_id)
                .unwrap();
            vec_p5adecom1.push(obj.0.clone());
        }
        vec_p5adecom1
    };
    let s_i = match local_sig.phase5d(
        &batch_p5ddecom2.values_sorted_by_key_asc(),
        &batch_p5com2.values_sorted_by_key_asc(),
        &vec_p5adecom1,
    ) {
        Ok(__) => __,
        Err(e) => throw!(ex, &format!("`phase5d` encounters the error \"{:?}\"", e)),
    };
    round += 1;
    progress.message("S9").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Finished GG18 Phase(5D)");
    // #endregion

    // #region round 9: GG18 Phase(5E)
    messenger.send_broadcast(round, &s_i).await.catch_()?;
    let batch_si = messenger.recv_broadcasts(round).await.catch_()?;
    let sig = match local_sig.output_signature(&batch_si.values_sorted_by_key_asc()) {
        Ok(__) => __,
        Err(e) => throw!(ex, &format!("Verification failed with error \"{:?}\"", e)),
    };
    check_sig(&sig.r, &sig.s, &message_bn, &pubkey).catch(ex, "")?;
    progress.message("S10").increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Checked signature");
    // #endregion

    // round 10: end mark
    let signature = Signature {
        r: sig.r.to_bigint().to_bytes(),
        s: sig.s.to_bigint().to_bytes(),
        v: sig.recid != 0,
    };
    let success = TerminationType::Sign(signature.clone());
    messenger.send_terminate(&success).await.catch_()?;
    progress
        .message("S-Fin")
        .harvest(Harvest::Signature(signature))
        .increase();
    ostream.send(Ok(progress.clone())).await.catch_()?;
    tracing::debug!("Sign completed");

    Ok(())
}

pub fn check_sig(
    r: &Scalar<Secp256k1>,
    s: &Scalar<Secp256k1>,
    msg: &BigInt,
    pk: &Point<Secp256k1>,
) -> Outcome<()> {
    // input parameter msg is a hashed value of the raw message to be signed
    let s_inv: Scalar<Secp256k1> = s.invert().unwrap_or_else(Scalar::<Secp256k1>::zero);
    let r_prime =
        (&s_inv * &Scalar::<Secp256k1>::from_bigint(msg)) * Point::generator() + (r * &s_inv) * pk;
    if r_prime.x_coord().unwrap_or_else(|| BigInt::from(0u16)) != r.to_bigint() {
        throw!("", "");
    }
    Ok(())
}
